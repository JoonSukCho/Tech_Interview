
Big O 표기법 이란?
 - 알고리즘의 효율성을 평가하기 위한 분석법

알고리즘 종류별 속도
버블 < 선택 < 퀵 < 힙 < 합병 < 삽입 < 쉘 < 기수 < 카운팅 정렬
* 참고 : https://yabmoons.tistory.com/250


선택 정렬
 - 주어진 리스트 중에 최솟값을 찾아서, 그 값을 맨 앞에 위치한 값과 교체한다.
   이 후, 맨 앞에 위치한 값을 제외하고 다시 최솟값을 찾아 그 다음의 위치와 교체한다.
 - 시간복잡도 O(n^2)
 - 장점 : 자료 이동 횟수가 미리 결정된다.


삽입 정렬
 - 하나의 값(Key)을 선정해서 자신보다 작은 값을 찾을 때 까지 이동하면서 위치를 교체한다.
 - 시간복잡도 O(n^2), 최선 - O(n)
 - 장점 : 안정한 정렬, 대부분의 레코드가 이미 정렬되어 있는 경우에 매우 효율적, 레코드 수가 적을 경우 효율적


버블 정렬
 - 서로 인접한 두 원소의 크기를 비교하여 크기가 순서대로 안되있으면 서로 교체한다.
 - 시간복잡도 O(n^2)
 - 장점 : 구현이 매우 간단.


퀵 정렬 [분할 정복 알고리즘]
 - 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고,
   분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법.
 - 시간복잡도 : 최선 - O(nlog2n)
	       최악 - O(n^2) 
	       평균 - O(nlog2n)


합병 정렬 [분할 정복 알고리즘]
 - 하나의 리스트를 균등한 크기로 분할 한 후 정렬한 다음, 다시 합치는 방법.
 - 시간복잡도 : 전부 - O(nlog2n)
 - 장점 : 레코드를 Linked List로 구성하면, 매우 효율적.
 - 단점 : 만약 레코드를 Array로 구성하면, 임시(temp) 배열이 필요하다.
 - 레코드의 크기가 큰 경우에는 매우 큰 시간 낭비 초래, But 연결 리스트를 사용한 큰 레코드라면, 매우 효율적


힙 정렬 [완전 이진 트리]
 - 내림차순 정렬을 위해서는 최대 힙 구성
 - 오름차순 정렬을 위해서는 최소 힙 구성
 - 시간복잡도 : 전부 - O(nlog2n)
 - 최댓값, 최솟값을 쉽게 추출할 수 있는 자료구조





